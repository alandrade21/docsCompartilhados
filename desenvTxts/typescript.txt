- Instalaçao
  ----------

  -- Instalando o typescript Globalmente
     --------------------------------

$ sudo npm install -g typescript

- teste 

$ tsc -v

- Config do typescript

$ tsc -init

- ligar a compilaçã automática

$ tsc -w

  -- Instalando o ts local no projeto
     --------------------------------

$ npm install typescript -D

A opção -D diz que essa é uma dependência de desenvolvimento, ou seja, ela vai para o devDepencencies do package.json.

- Configuração
  ------------

No tsconfig.json, usa as seguintes propriedades em novos sistemas:
  "noImplicityAny": true,
  "strictNullChecks": true,
  "noEmitOnError": true,      // Não compila em caso de erro
  "sourceMap": true           // Permite debugar

- ES6
  ---

  -- Variáveis
     ---------

Variável de constante com objeto atribuído. O conteúdo do objeto não é imutável:
  const objeto = { atributo: 'olá!' };
  objeto.atributo = '';

  -- Arrow Function
     ---------------

O uso de arrow function não cria um novo escopo, como o uso do comando function faz.

  -- Template String
     ---------------

`Qualquer texto concatenado com ${variavel}`

Template strings aceita quebra de linha, e reproduz essa quebra de linha na saída.

  -- Optional Parameters
     -------------------

By default value: function fazAlgo(param1, param2 = ''); 
  Nesse caso, se a função for chamada só com 1 parâmetro, o segundo é usado com seu valor default.

  -- Concatenação de Arrays
     ----------------------

const array1 = ['a', 'b', 'c'];

const array2 = [...array1, 'd'];

  -- Varargs
     -------
function fazAlgo(param1, ...param2); 

- Types
  -----

  -- Atributos Opcionais
     -------------------

type NovoTipo = {
  campo1?: string,  // Esse é opcional.
  campo2: string
};

  -- Tuplas
     ------

type Tupla = [string, number];

let minhaTupla: Tupla = ['Andre', 1];

  -- Enum
     ----

enum PlayerPosition {
  Guard, Forward, Center
}

Um enum é convertido em int, iniciando em 0, na ordem de declaração.

Para obter o enum value com base numa string, usa PlayerPosition["Guard"].

Para obter a string de um enum faz PlayerPosition[x], onde x é o índice do enum.

  -- Non Nullable Types
     ------------------

Para impedir que uma variável de um tupo possa receber null ou undefined, vai no tsconfig.json e coloca a propriedade;
  "strictNullChecks": true

Depois de setar isso, para fazer com que um null ou undefined sejam aceitos, é necessário fazer:
  let minhaVariavel: MeuTipo | null | undefined;

  -- Vários Tipos
     ------------

Um tipo ou outro: 
  let mensagem: string | number;

Combinação de tipos:
  interface HasName { firstName: string, lastName: string };
  interface HasAddress { address: string };
  type Player = HasName & HasAddress;

  -- Tipo Any
     --------

Any funciona por fora da checagem de tipos do compilador, então:
  let myVar: any;
  myvar = {};
  let str:string = '';
  str = myVar;
É válido. Any, efetivamente troca o tipo e contorna o sistema de checagem de tipos.

Para evitar que o compilador associe o tipo any por inferência qdo não conseguir descobrir o tipo, coloca no tsconfig.json a propriedade
  "noImplicityAny": true

  -- Third Party Types
     -----------------

Se for usar o comando require da commonjs, tem que instalar:
  $ npm install @types/node --save-dev

Qdo for usar uma biblioteca de terceiros que não tem definição de tipos embutida, sempre instala, além da biblioteca:
  $ npm install @types/<<biblioteca>> --save-dev

Para usar as definições de tipo no programa, ao invés de usar require, usa import. Ex:
  Ao invés de:
    const _ = require('lodash');
  usa:
    import * as _ from 'lodash'; // ES6 syntax

Se a biblioteca não tiver uma definição de tipos, seja interna ou externa, tem que criar uma. Um arquivo de definição de tipos é nomeado com a extensão .d.ts. Usando lodash como exemplo:
  lodash.d.ts:
    declare interface FirstFunction { (data: any[]): any; }
    declare interface Lodash { first: FirstFunction; }
  seuCodigo.ts:
    const _: Lodash = require('lodash');
    const colors = ["Red", "Green", "Blue"];
    const firstColor = _.first(colors);

No exemplo acima, para usar o comando import ao invés do require é necessário criar um módulo:
  lodash.d.ts:
    declare module "lodash" {
      declare interface FirstFunction { (data: any[]): any; }
      declare interface Lodash { first: FirstFunction; }
      export const _: Lodash;
    }
  seuCodigo.ts:
    import { _ } from "lodash";

  -- Never Type
     ----------

Se uma função nunca retorna nada, só dispara um erro, essa função deve ser marcada como do tipo never. Ou seja, essas funções nunca atingem um ponto de retorno.

  -- Compatibilidade entre Tipos
     ---------------------------

Em TS, a compatibilidade de tipos é constatada não pelo nome do tipo, mas pela sua estrutura interna. Se a estrutura interna for a mesma (ou for compatível), mesmo que os nomes sejam diferentes, os tipos são compatíveis.


- Debug
  -----

Para adicionar um break point de forma programática, coloca no código:
  debugger;

- Classes
  -------

  -- Getter & Setter
     ---------------

class SuperHero {
  constructor(
    private name: string
  ){}

  get name(): string {
    return this.name;
  }

  set name(name: string) {
    this.name = name;
  }
}

const superman = new SuperHero('superman');
console.log(superman.name); // isso usa o getter.
superman.name = 'Clark Kent'; // iso usa o setter.

  -- Read Only Members
   -----------------

private readonly name: string = '';

- Generics
  --------

Ao invés de escrever 
  function cloneArray(array: any[]): any[]
escreve
  function cloneArray<T>(array: T[]): T[]



